function [CF] = fitness_function_2D_GA(excite,phasorMatrix)
%% An objective function which will be used in conjunction with SimAnnealDriverv01.m
%   University College Dublin (UCD)
%   School of Electrical, Electronic & Communications Engineering
%
%   Author: Jonathan D. Gorman
%   Project: Beam Pattern Synthesis in Sensor Arrays Using Optimisation
%   Algorithms
%
%   A driver .m file for the implementation of a Greedy algorithm
%   for optimising a 32 element WSN array
%
%   Version: 0.2 - 22/04/2015
%
%   This function holds the cost) functions which
%   the genetic algorithms attempt to minimise
%   The function has two inputs as follows:
%
%   Inputs:
%   1) excite = excitation vector applied to the array
%   2) erBrokenOriginal - the original eR vector which represents the
%      original ULA with broken elements.
%
%   As well as a single output:
%   1) CF - The objective (cost) function value
%-------------------------------------------------------------------------%
%% Objective Function
% recombining excitations
exciteComb = [(excite(1) + excite(2)*1j)...
    (excite(3) + excite(4)*1j)...
    (excite(5) + excite(6)*1j)...
    (excite(7) + excite(8)*1j)...
    (excite(9) + excite(10)*1j)...
    (excite(11) + excite(12)*1j) ...
    (excite(13) + excite(14)*1j)...
    (excite(15) + excite(16)*1j)...
    (excite(17) + excite(18)*1j) ...
    (excite(19) + excite(20)*1j)...
    (excite(21) + excite(22)*1j)...
    (excite(23) + excite(24)*1j)...
    (excite(25) + excite(26)*1j)...
    (excite(27) + excite(28)*1j)...
    (excite(29) + excite(30)*1j)...
    (excite(31) + excite(32)*1j)...
    (excite(33) + excite(34)*1j)...
    (excite(35) + excite(36)*1j)...
    (excite(37) + excite(38)*1j)...
    (excite(39) + excite(40)*1j)...
    (excite(41) + excite(42)*1j)...
    (excite(43) + excite(44)*1j)...
    (excite(45) + excite(46)*1j)...
    (excite(47) + excite(48)*1j)...
    (excite(49) + excite(50)*1j)...
    (excite(51) + excite(52)*1j)...
    (excite(53) + excite(54)*1j)...
    (excite(55) + excite(56)*1j)...
    (excite(57) + excite(58)*1j)...
    (excite(59) + excite(60)*1j)...
    (excite(61) + excite(62)*1j)...
    (excite(63) + excite(64)*1j)];

er = phasorMatrix*exciteComb'; % create beampattern

mainBeam = max(abs(er(190:210))); % set bounds in which Main Beam can be found
maxSidelobe1 = max(abs(er(1:175))); % set bounds in which max SL1 can be found + don't care region
maxSidelobe2 = max(abs(er(225:end))); % set bounds in which max SL2 can be found + don't care region
maxSidelobe = max([maxSidelobe1 maxSidelobe2]); % choose maximum sidelobe
beamRatio = maxSidelobe/mainBeam; % calculate corresponding Beam Ratio

CF = beamRatio; % the objective (cost) function

end
